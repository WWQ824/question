# APP卡顿优化

## CPU

* 尽量使用轻量级的对象, 比如用不到事件处理的地方, 可以考虑使用`CALayer`取代`UIView`
* 不要频繁地调用`UIView`的相关属性, 比如`frame``bounds``transform`等属性, 尽量减少不必要的修改, 尽量提前计算好布局, 在有需要时候一次性调整对应的属性, 不要多次修改属性(修改一次就会刷新布局一次)
* `AutoLayout`会比直接设置`frame`消耗更多的**CPU**资源
* 图片的`size`最好刚好跟`UIImageView`的`size`保持一致(会缩放图片浪费CPU资源)
* 控制线程的最大并发数(假设线程数很多,占用CPU资源)
* 尽量把耗时的操作放到子线程(减少CPU资源消耗)
  * 文本处理(尺寸计算, 绘制)
  * 图片处理(解码, 绘制)


## GPU
* 尽量减少视图数量和层次
* 尽量避免短时间内大量图片的显示, 尽量可能将多张图片合成一张进行显示
* GPU能处理的最大纹理尺寸是4096x4096, 一旦超过这个尺寸, 就会占用CPU资源进行处理, 所以纹理尽量不要超过这个尺寸
* 减少透明的视图(alpha<1), 不投的就设置opaque为YES
* 尽量避免出现离屏渲染


# 什么是离屏渲染?
* 在`OpenGL`中, GPU有2种渲染方式
  1. On-Screen Rendering:当前屏幕渲染, 在当前用于显示的屏幕缓冲区进行渲染操作
  2. Off-Screen Rendering:离屏渲染, 在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作
* 离屏渲染消耗性能的原因
  1. 需要创建新的缓冲区
  2. 离屏渲染的整个过程, 需要多次切换上下文环境, 先是从当前屏幕切换到离屏; 等到离屏渲染结束以后, 将离屏缓冲区的渲染结果先是到屏幕上, 又将上下文环境从离屏切换到当前屏幕
* 哪些操作会触发离屏渲染?
  * 光栅化,`layer.shouldRasterize = YES`
  * 遮罩, `layer.mask`
  * 圆角, 同时设置`layer.maskToBounds = YES, layer.cornerRadius大于0`(通过`CoreFraphics`绘制裁剪圆角或者使用圆角图片)
  * 阴影, `layer.shadowXXX`(如果设置了`layer.shadowPath`就不会产生离屏渲染)

# 卡顿检测
添加Observer到RunLoop, 通过监听RunLoop状态切换的耗时, 以达到监控卡顿的目的.

